---
title: 元胞自动机
date: 2019-11-12 00:51:18
tags:
  - 数模
toc: true
---

<img src="元胞自动机\00.png">

# Cellular Automata & Monte Carlo （元胞自动机及蒙特卡罗方法）
<!-- more -->
<The rest of contents | 余下全文>

## 概述
* 时间、空间都离散的动力系统
* 不同于数学方程模型，由一系列模型构造的规则构成的方法框架。
* 特点：时间、空间、状态离散。
* 用简单的逻辑规则，给出一种随时间演化的动力学模型，使之能模拟复杂系统。

## 元胞自动机
### 历史
* 20世纪50年代，John von Neumann 最早提出；
* 1970年，John Conway 提出生命游戏 (Conway, J. (1970). In M. Gardner, (Ed.), Scientific American, 223(4), pp. 120-123.)
* 1983年，Stephen Wolfram 初等元胞自动机(Stephen Wolfram. Reviews of Modern Physics,1983, Vol.55)
* 1986年至今，理论及应用

### 一维元胞自动机

一维格子：长为$L$的线段，$L$等份，得$L$个格子，构成一维格子。

格子的状态
* 每个格子有两种状态，且状态是随时间变化的。     
* 将$i$格子在$t$时刻的状态记为 $x_{i}^{t}$ ，规定
$$
x_{i}^{t}=\left\{\begin{array}{l}{0} \\ {1}\end{array}, i=1,2, \cdots \cdots, L\right.
$$

状态的更新机制

$$
x_{i}^{t+1}=f\left(x_{i-1}^{t}, x_{i}^{t}, x_{i+1}^{t}\right), \quad i=1,2, \cdots \cdots, L
$$

采用周期边界


### 时空图
L=100， 初值取$x_{i}^{0}=\left\{\begin{array}{ll}{1} & {i=50} \\ {0} & {i \neq 50}\end{array}\right.$  
用白色表示0状态，用黑色表示1状态。  
对给定规则，演化100时间步，可得如下结构时空图

<img src="元胞自动机\01.png">


### 二维元胞自动机

二维格子：将边长为L的正方形，每边L等份得到的L*L个格子。

格子状态：将$(i,j)$格子在$t$时刻的状态记为 $x_{i, j}^{t}$, $(i,j)$ 格子状态的种类由具体问题确定

格子的邻居
* Von Neumann 邻居   
* Moore邻居

状态更新机制：

$$
x_{i, j}^{t+1}=f\left(x_{i-1, j}^{t}, x_{i+1, j}^{t} x_{i, j}^{t}, x_{i, j-1}^{t}, x_{i, j+1}^{t}\right)
$$  
其中 $i, j=1,2, \cdots \cdots, L$

采用周期边界  

元胞自动机方法
* 对每个格子，制定状态改变的局部规则。
* 采用同步更新的方法，进行状态更新。

## 蒙特卡洛方法
随机选定格子
* 对格子及其邻居制定状态改变的局部规则。
* 采用异步更新的方法，进行状态更新。
* Monte-Carlo步与时间步
* Monte-Carlo步：按局部规则完成的一次更新为一个Monte-Carlo步
* 时间步：对 $L*L$ 格子，一般 $L^2$ 个Monte-Carlo步为一个时间步

## 总结
* 在$L*L$格子上，规定每个格子的状态种类数
* 根据具体问题背景，通过制定局部规则，建立格子状态的更新机制，通过计算机模拟研究相应系统的演化规律。
* 局部规则可采用元胞自动机方法或蒙特卡洛方法。
* 元胞自动机方法通过局部规则改变一个格子的状态，且所有格子同步更新。
* 蒙特卡洛方法通过局部规则以随机确定格子的方法，改变该格子及其局部的状态。

## 实验：元胞自动机时空图

CODE
``` python
"""
元胞自动机时空图 Python 实现
"""
%matplotlib inline

import numpy as np
import matplotlib.pyplot as plt
 

class CellularAutomata(object):
 
    def __init__(self, cells_lenth, rules=None):
        """
        Parameters
        ----------
        cells_lenth : 一维元胞自动机长度

        Examples
        --------
        创建一个长度为100的一位格子
        ca =  CellularAutomata(100)

        """

        # 矩阵的四周不参与运算
        self.lenth = cells_lenth
        self.n_iter = 101 # 演化次数
        self.timer = 0    # 当前迭代次数
        if rules:
            self.rules = rules
        else:
            self.rules = {(0,0,0):1, (0,0,1):1, (1,1,0):1, (1,0,1):1,
                          (1,1,1):0, (0,1,0):0, (0,1,1):0, (1,0,0):0} # 定义演化规则
        self.cells = np.zeros((cells_lenth, self.n_iter))
        self.cells[0, int(cells_lenth/2)] = 1 
        
    def update_state(self):
        """更新一次状态"""
        i = self.timer + 1 # 当前要更新的行
        for j in range(self.lenth):
            # 计算该细胞周围的存活细胞数
            (x, y, z) = (self.cells[i-1, (j-1+self.lenth)%self.lenth],
                         self.cells[i-1, j],
                         self.cells[i-1, (j+1+self.lenth)%self.lenth])
            self.cells[i, j] = self.rules[(x,y,z)]
        self.timer += 1
   
    def plot_state(self):
        """画出当前的状态"""
        plt.title('Iter :{}'.format(self.timer))
        plt.imshow(self.cells)
        plt.show()
 
    def update_and_plot(self, n_iter):
        """更新状态并画图
        Parameters
        ----------
        n_iter : 更新的轮数
        """
        plt.ion()
        for _ in range(n_iter):
            plt.title('Iter :{}'.format(self.timer))
            plt.imshow(self.cells)
            self.update_state()
            plt.pause(0.000001)
        plt.ioff()
        
    def update(self, n_iter):
        """更新状态并画图
        Parameters
        ----------
        n_iter : 更新的轮数
        """
        for _ in range(n_iter):
            self.update_state()

if __name__ == '__main__':
    plt.figure(figsize=(16,8))

    rules_list = [
        {(0,0,0):1, (0,0,1):1, (1,1,0):1, (1,0,1):1,
         (1,1,1):0, (0,1,0):0, (0,1,1):0, (1,0,0):0}, 
        {(0,0,0):1, (0,0,1):0, (1,1,0):1, (1,0,1):1,
         (1,1,1):0, (0,1,0):1, (0,1,1):0, (1,0,0):0}, 
        {(0,0,0):0, (0,0,1):1, (1,1,0):0, (1,0,1):0,
         (1,1,1):0, (0,1,0):1, (0,1,1):0, (1,0,0):1}, 
        {(0,0,0):1, (0,0,1):0, (1,1,0):1, (1,0,1):1,
         (1,1,1):0, (0,1,0):0, (0,1,1):1, (1,0,0):0}, 
        {(0,0,0):0, (0,0,1):1, (1,1,0):1, (1,0,1):0,
         (1,1,1):0, (0,1,0):1, (0,1,1):0, (1,0,0):1}, 
        {(0,0,0):0, (0,0,1):0, (1,1,0):1, (1,0,1):1,
         (1,1,1):0, (0,1,0):1, (0,1,1):1, (1,0,0):1}, 
        {(0,0,0):1, (0,0,1):0, (1,1,0):0, (1,0,1):1,
         (1,1,1):1, (0,1,0):1, (0,1,1):0, (1,0,0):1}, 
        {(0,0,0):1, (0,0,1):0, (1,1,0):1, (1,0,1):0,
         (1,1,1):0, (0,1,0):0, (0,1,1):1, (1,0,0):0}, 
    ]
    cas = [CellularAutomata(100, rules) for rules in rules_list]
    for i,ca in enumerate(cas):
        ca.update(99)
        plt.subplot(2,4,i+1)
        plt.imshow(ca.cells)
        plt.axis('off')  #去掉坐标轴
```

结果
<img src="元胞自动机\02.png">

