---
title: 门禁人脸检测和识别
date: 2019-06-25 18:08:41
tags:
  - opencv
  - python
---
** {{ title }}：** <Excerpt in index | 首页摘要>
<img src="门禁人脸检测和识别\demo.gif">

<!-- more -->
<The rest of contents | 余下全文>


## 人脸检测

### OpenCV库
* ### 基于haar特征和adaboost分类器的人脸检测
Haar分类器 = Haar-like特征 + 积分图方法 + AdaBoost +级联；  
Haar分类器算法的要点如下：  
①　使用Haar-like特征做检测。  
②　使用积分图（Integral Image）对Haar-like特征求值进行加速。  
③　使用AdaBoost算法训练区分人脸和非人脸的强分类器。  
④　使用筛选式级联把强分类器级联到一起，提高准确率。 
``` python
faceCascade = cv2.CascadeClassifier('./haarcascade_frontalface_default.xml')

def detectFaceOpenCVHaar(faceCascade, frame, inHeight=300, inWidth=0):
    frameOpenCVHaar = frame.copy()
    frameHeight = frameOpenCVHaar.shape[0]
    frameWidth = frameOpenCVHaar.shape[1]
    if not inWidth:
        inWidth = int((frameWidth / frameHeight) * inHeight)

    scaleHeight = frameHeight / inHeight
    scaleWidth = frameWidth / inWidth

    frameOpenCVHaarSmall = cv2.resize(frameOpenCVHaar, (inWidth, inHeight))
    frameGray = cv2.cvtColor(frameOpenCVHaarSmall, cv2.COLOR_BGR2GRAY)

    faces = faceCascade.detectMultiScale(frameGray)
    bboxes = []
    for (x, y, w, h) in faces:
        x1 = x
        y1 = y
        x2 = x + w
        y2 = y + h
        cvRect = [int(x1 * scaleWidth), int(y1 * scaleHeight),
                  int(x2 * scaleWidth), int(y2 * scaleHeight)]
        bboxes.append(cvRect)
        cv2.rectangle(frameOpenCVHaar, (cvRect[0], cvRect[1]), (cvRect[2], cvRect[3]), (0, 255, 0),
                      int(round(frameHeight / 150)), 4)
    return frameOpenCVHaar, bboxes
```

* ### 基于DNN的人脸检测
在OpenCV3.3版本发布中把DNN模块从扩展模块移到了OpenCV正式发布模块中，OpenCV做了近一步扩展支持所有主流的深度学习框架训练生成与导出模型数据加载。 
``` python 
def detectFaceOpenCVDnn(net, frame):
    frameOpencvDnn = frame.copy()
    frameHeight = frameOpencvDnn.shape[0]
    frameWidth = frameOpencvDnn.shape[1]
    blob = cv2.dnn.blobFromImage(frameOpencvDnn, 1.0, (300, 300), [104, 117, 123], False, False)

    net.setInput(blob)
    detections = net.forward()
    bboxes = []
    for i in range(detections.shape[2]):
        confidence = detections[0, 0, i, 2]
        if confidence > conf_threshold:
            x1 = int(detections[0, 0, i, 3] * frameWidth)
            y1 = int(detections[0, 0, i, 4] * frameHeight)
            x2 = int(detections[0, 0, i, 5] * frameWidth)
            y2 = int(detections[0, 0, i, 6] * frameHeight)
            bboxes.append([x1, y1, x2, y2])
            cv2.rectangle(frameOpencvDnn, (x1, y1), (x2, y2), (0, 255, 0), int(round(frameHeight/150)), 8)
    return frameOpencvDnn, bboxes
```
openCV人脸检测的实例中，DNN模块支持两个框架的模型：   
若为caffe模型，则使用readNetFromCaffe，需要用到.prototxt格式的配置文件和.caffemodel格式的模型文件；  
``` python
# 1. FP16 version of the original caffe implementation ( 5.4 MB )
modelFile = "models/res10_300x300_ssd_iter_140000_fp16.caffemodel"
configFile = "models/deploy.prototxt"
net = cv2.dnn.readNetFromCaffe(configFile, modelFile)
```
若为tensorflow模型，则使用readNetFromTensorflow，需要用到.pbtxt格式的配置文件和.pb格式的模型文件。
``` python
# 2. 8 bit Quantized version using Tensorflow ( 2.7 MB )
modelFile = "models/opencv_face_detector_uint8.pb"
configFile = "models/opencv_face_detector.pbtxt"
net = cv2.dnn.readNetFromTensorflow(modelFile, configFile)
```

### Dlib库
Dlib 是一个十分优秀好用的机器学习库，其源码均由 C++ 实现，并提供了 Python 接口，可广泛适用于很多场景。  
> * dlib C++ Library  
> http://dlib.net/ 

* ### 基于HOG特征和线性分类器的人脸检测
采用经典的HOG(Histogram of Oriented Gradients)特征结合线性分类器、图像金字塔(image pyramid)及滑窗检测机制(sliding window detection scheme)实现的人脸检测器。
``` python
hogFaceDetector = dlib.get_frontal_face_detector()

def detectFaceDlibHog(detector, frame, inHeight=300, inWidth=0):

    frameDlibHog = frame.copy()
    frameHeight = frameDlibHog.shape[0]
    frameWidth = frameDlibHog.shape[1]
    if not inWidth:
        inWidth = int((frameWidth / frameHeight)*inHeight)

    scaleHeight = frameHeight / inHeight
    scaleWidth = frameWidth / inWidth

    frameDlibHogSmall = cv2.resize(frameDlibHog, (inWidth, inHeight))

    frameDlibHogSmall = cv2.cvtColor(frameDlibHogSmall, cv2.COLOR_BGR2RGB)
    faceRects = detector(frameDlibHogSmall, 0)
    print(frameWidth, frameHeight, inWidth, inHeight)
    bboxes = []
    for faceRect in faceRects:

        cvRect = [int(faceRect.left()*scaleWidth), int(faceRect.top()*scaleHeight),
                  int(faceRect.right()*scaleWidth), int(faceRect.bottom()*scaleHeight) ]
        bboxes.append(cvRect)
        cv2.rectangle(frameDlibHog, (cvRect[0], cvRect[1]), (cvRect[2], cvRect[3]), (0, 255, 0), int(round(frameHeight/150)), 4)
    return frameDlibHog, bboxes
```

* ### 基于CNN的人脸检测
采用预训练的CNN模型进行图片中的人脸检测。  
基于CNN模型比基于HOG特征模型的人脸检测准确度更高，但是需要更多的计算资源，即在GPU上运行才可有较好的运行速率。

``` python
dnnFaceDetector = dlib.cnn_face_detection_model_v1("./mmod_human_face_detector.dat")

def detectFaceDlibMMOD(detector, frame, inHeight=300, inWidth=0):

    frameDlibMMOD = frame.copy()
    frameHeight = frameDlibMMOD.shape[0]
    frameWidth = frameDlibMMOD.shape[1]
    if not inWidth:
        inWidth = int((frameWidth / frameHeight)*inHeight)

    scaleHeight = frameHeight / inHeight
    scaleWidth = frameWidth / inWidth

    frameDlibMMODSmall = cv2.resize(frameDlibMMOD, (inWidth, inHeight))

    frameDlibMMODSmall = cv2.cvtColor(frameDlibMMODSmall, cv2.COLOR_BGR2RGB)
    faceRects = detector(frameDlibMMODSmall, 0)

    print(frameWidth, frameHeight, inWidth, inHeight)
    bboxes = []
    for faceRect in faceRects:
        cvRect = [int(faceRect.rect.left()*scaleWidth), int(faceRect.rect.top()*scaleHeight),
                  int(faceRect.rect.right()*scaleWidth), int(faceRect.rect.bottom()*scaleHeight) ]
        bboxes.append(cvRect)
        cv2.rectangle(frameDlibMMOD, (cvRect[0], cvRect[1]), (cvRect[2], cvRect[3]), (0, 255, 0), int(round(frameHeight/150)), 4)
    return frameDlibMMOD, bboxes
```



## 参考
* Face Detection - OpenCV, Dlib and Deep Learning | Learn OpenCV  
https://www.learnopencv.com/face-detection-opencv-dlib-and-deep-learning-c-python/









