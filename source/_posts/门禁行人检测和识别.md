---
title: 门禁行人检测和识别
date: 2019-07-23 10:29:26
tags:
---


## 远程桌面连接

* 利用远程桌面连接

在ubuntu安装xdrp服务
``` bash
sudo apt-get install xrdp
```
打开远程桌面服务（mstsc.exe），输入ip连接


## 使用Flask构建实时视频流服务器

狗书作者 Miguel 在 [Video Streaming with Flask](https://blog.miguelgrinberg.com/post/video-streaming-with-flask) 中提出了一个简单实用的流媒体服务器，之后在 [Flask Video Streaming Revisited](https://blog.miguelgrinberg.com/post/flask-video-streaming-revisited) 中对其进行了优化。


* Video Streaming with Flask - miguelgrinberg.com  
https://blog.miguelgrinberg.com/post/video-streaming-with-flask

* Flask Video Streaming Revisited - miguelgrinberg.com  
https://blog.miguelgrinberg.com/post/flask-video-streaming-revisited



流是一种让服务器在响应请求时将响应数据分块的技术。

Flask 通过使用 生成器（generator functions） 原生支持流式响应。


### 分部响应

让每一个数据块取代页面中的前一块，这样流就能够在浏览器窗口中进行“播放”，以实现在浏览器中运行一个视频播放器的功能。实现原地更新的秘诀在于使用 multipart（分部） 响应。分部响应的内容是一个包含分部内容类型的头部，后面的是用 boundary（分界线） 标记分割的部分，每一部分有各自的特定内容类型。

分部视频流的格式如下：
``` http
HTTP/1.1 200 OK
Content-Type: multipart/x-mixed-replace; boundary=frame

--frame
Content-Type: image/jpeg

<jpeg data here>
--frame
Content-Type: image/jpeg

<jpeg data here>
...
```

### 构建一个实时视频流服务器

``` python
#!/usr/bin/env python
from flask import Flask, render_template, Response
from camera import Camera

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

def gen(camera):
    while True:
        frame = camera.get_frame()
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')

@app.route('/video_feed')
def video_feed():
    return Response(gen(Camera()),
                    mimetype='multipart/x-mixed-replace; boundary=frame')

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True)
```

Camera 类负责提供帧序列。

该应用有两个路由。路由 / 提供定义在 index.html 模版中的主页面。

``` html
<html>
  <head>
    <title>Video Streaming Demonstration</title>
  </head>
  <body>
    <img src="{{ url_for('video_feed') }}">
  </body>
</html>
```

这是个简单的 HTML 页面，只有一个 heading 和一个图片标签。注意图片标签的 src 属性指向的是该应用的第二个路由，而这正是奇妙的地方。

路由 /video_feed 返回的是流式响应。因为流返回的是可以显示在网页中的图片，到该路由的 URL 就放在图片标签的 src 属性中。浏览器会自动显示流中的 JPEG 图片，从而保持图片更新。

在 /video_feed 路由中用到的生成器函数叫做 gen()，它接收 Camera 类的实例作为参数。为了达到让流中的每部分能够替代前一部分的目的，内容类型mimetype 必须为 multipart/x-mixed-replace，边界字符串设置为 frame。

gen() 函数进入循环，从而持续地将摄像头中获取的帧数据作为响应块返回。该函数通过调用 camera.get_frame() 方法从摄像头中获取一帧数据，然后它将这一帧以内容类型为 image/jpeg 的响应块形式产出（yield）。


### 流的局限

* 在处理永不结束的、长的流时，比如从摄像机发来的一个视频流，web worker 将会对客户端保持锁定状态，直到客户端断开连接。
* Flask应用只有一个线程，因此无法打开多个浏览器窗口同时观看视频。


### 仅在有观看者时运行相机

记录每次客户端访问视频祯的时间，Camera线程检查时间戳，如果超过十秒则退出，一旦客户端再次连接，线程就会重新启动。

``` python
class Camera(object):
    # ...
    last_access = 0  # 最后一个客户端访问相机的时间
 
    def get_frame(self):
        Camera.last_access = time.time()
        # ...
 
    @classmethod
    def _thread(cls):
        with picamera.PiCamera() as camera:
            # ...
            for foo in camera.capture_continuous(stream, 'jpeg', use_video_port=True):
                # ...
                # 如果没有任何客户端访问视屏帧
                # 10 秒钟之后停止线程
                if time.time() - cls.last_access > 10:
                    break
        cls.thread = None
```

### 性能优化

后台线程捕获帧与将这些帧回送到客户端的生成器之间需要同步，生成器仅将原始帧传递给客户端。如果生成器内的传送回路比相机线程的帧速率快，则生成器应该等待直到新帧可用，所以它应该自行调整以匹配相机速率；另一方面，如果传送回路以比相机线程更慢的速率运行，那么它在处理帧时永远不应该落后，而应该跳过某些帧以始终传递最新的帧。

解决方案是，当新帧可用时，让相机线程信号通知生成器运行。然后，生成器可以在它们传送下一帧之前等待信号时阻塞。在查看同步单元时，我发现 threading.Event 是匹配此行为的函数。所以，基本上每个生成器都应该有一个事件对象，然后摄像机线程应该发出信号通知所有活动事件对象，以便在新帧可用时通知所有正在运行的生成器。生成器传递帧并重置其事件对象，然后等待它们再次进行下一帧。

为了避免在生成器中添加事件处理逻辑，实现一个自定义事件类，该事件类使用调用者的线程 id 为每个客户端线程自动创建和管理单独的事件。说实话，这有点复杂，但这个想法来自于 Flask 的上下文局部变量是如何实现的。新的事件类称为 CameraEvent，并具有 wait()、set() 和 clear() 方法。在此类的支持下，可以将速率控制机制添加到 BaseCamera 类：

``` python
class CameraEvent(object):
    # ...
 
class BaseCamera(object):
    # ...
    event = CameraEvent()
 
    # ...
 
    def get_frame(self):
        """返回相机的当前帧."""
        BaseCamera.last_access = time.time()
 
        # wait for a signal from the camera thread
        BaseCamera.event.wait()
        BaseCamera.event.clear()
 
        return BaseCamera.frame
 
    @classmethod
    def _thread(cls):
        # ...
        for frame in frames_iterator:
            BaseCamera.frame = frame
            BaseCamera.event.set()  # send signal to clients
 
            # ...
```
在 CameraEvent 类中完成的魔法操作使多个客户端能够单独等待新的帧。wait() 方法使用当前线程 id 为每个客户端分配单独的事件对象并等待它。clear() 方法将重置与调用者的线程 id 相关联的事件，以便每个生成器线程可以以它自己的速度运行。相机线程调用的 set() 方法向分配给所有客户端的事件对象发送信号，并且还将删除未提供服务的任何事件，因为这意味着与这些事件关联的客户端已关闭，客户端本身也不存在了。



### 部署Web服务器
使用比 Flask 附带的服务器更强大的 Web服务器，一个很好的选择是使用 Gunicorn。

``` bash
gunicorn --threads 5 --workers 1 --bind 0.0.0.0:5000 app:app
```


























